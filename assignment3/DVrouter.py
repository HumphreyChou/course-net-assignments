####################################################
# DVrouter.py
# Name:
# JHED ID:
#####################################################

from packet import Packet
import sys
from collections import defaultdict
from router import Router
from json import dumps, loads

INF = 16 # enough for this assignment

class DVrouter(Router):
    """Distance vector routing protocol implementation."""

    def __init__(self, addr, heartbeatTime):
        """TODO: add your own class fields and initialization code here"""
        Router.__init__(self, addr)  # initialize superclass - don't remove
        self.heartbeatTime = heartbeatTime
        self.last_time = 0
        # Hints: initialize local state
        self.dis_vec = defaultdict(lambda: INF) # address (string) -> distance (int)
        self.dis_vec[self.addr] = 0
        self.forward_table = defaultdict(lambda: None) # address (string) -> port number (int)
        self.ports = defaultdict(lambda: [None, INF, None]) # port number (int) -> [address (string), cost (int), distance vector (dict)]

    def broadcastDisVec(self, table):
        for port, neighbour in self.ports.items():
            if neighbour[0] == None:
                continue
            if neighbour[0] in table.keys():
                dis_vec = self.dis_vec.copy()
                dis_vec[table[neighbour[0]]] = INF
                packet = Packet(kind=Packet.ROUTING, srcAddr=self.addr, dstAddr=neighbour[0], content=dumps(dis_vec))
            else:
                packet = Packet(kind=Packet.ROUTING, srcAddr=self.addr, dstAddr=neighbour[0], content=dumps(self.dis_vec))
            self.send(port, packet)


    def handlePacket(self, port, packet):
        """TODO: process incoming packet"""
        if packet.isTraceroute():
            # Hints: this is a normal data packet
            # if the forwarding table contains packet.dstAddr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if packet.dstAddr in self.forward_table.keys():
                self.send(self.forward_table[packet.dstAddr], packet)
        else:
            # Hints: this is a routing packet generated by your routing protocol
            # if the received distance vector is different
            #   update the local copy of the distance vector
            #   update the distance vector of this router
            #   update the forwarding table
            #   broadcast the distance vector of this router to neighbors
            neighbour_dis_vec = loads(packet.content)
            # add new address in this router's distance vector
            for addr, dis in neighbour_dis_vec.items():
                if addr not in self.dis_vec:
                    self.dis_vec[addr] = INF
            self.ports[port][2] = neighbour_dis_vec # update neighbour's distance vector
            poisoned_rev_table = {} # record poisoned reverse
            for addr, dis in self.dis_vec.items():
                # Bellman-Ford
                new_port, new_dis = None, dis
                for port_num, neighbour in self.ports.items():
                    if neighbour[2] and addr in neighbour[2] and new_dis > neighbour[1] + neighbour[2][addr]:
                        new_dis = neighbour[1] + neighbour[2][addr]
                        new_port = port_num
                if new_port and new_dis:
                    self.dis_vec[addr] = new_dis
                    self.forward_table[addr] = new_port
                    poisoned_rev_table[neighbour[0]] = addr
            if poisoned_rev_table:
                self.broadcastDisVec(poisoned_rev_table.copy())


    def handleNewLink(self, port, endpoint, cost):
        """TODO: handle new link"""
        # update the distance vector of this router
        # update the forwarding table
        # broadcast the distance vector of this router to neighbors
        self.ports[port] = [endpoint, cost, None]
        if self.dis_vec[endpoint] > cost:
            self.dis_vec[endpoint] = cost
            self.forward_table[endpoint] = port
            self.broadcastDisVec({}) 


    def handleRemoveLink(self, port):
        """TODO: handle removed link"""
        # update the distance vector of this router
        # update the forwarding table
        # broadcast the distance vector of this router to neighbors
        self.ports[port] = [None, INF, None]
        for addr, port_num in self.forward_table.items():
            if port_num == port:
                self.forward_table[addr] = None
                self.dis_vec[addr] = INF
        self.broadcastDisVec({})


    def handleTime(self, timeMillisecs):
        """TODO: handle current time"""
        if timeMillisecs - self.last_time >= self.heartbeatTime:
            self.last_time = timeMillisecs
            # broadcast the distance vector of this router to neighbors
            self.broadcastDisVec({})


    def debugString(self):
        """TODO: generate a string for debugging in network visualizer"""
        return "router: addr {}\n ports: {}\n dis_vec: {}\n forward_table: {}" \
            .format(self.addr, [(port[0], port[1]) for port in self.ports.values()], \
                [(addr, dis) for addr, dis in self.dis_vec.items()], \
                    [(addr, port) for addr, port in self.forward_table.items()])