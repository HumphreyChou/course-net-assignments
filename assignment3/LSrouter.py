####################################################
# LSrouter.py
# Name:
# JHED ID:
#####################################################

import sys
from collections import defaultdict
from router import Router
from packet import Packet
from json import dumps, loads
import networkx as nx


INF = 16

class LSrouter(Router):
    """Link state routing protocol implementation."""

    def __init__(self, addr, heartbeatTime):
        """TODO: add your own class fields and initialization code here"""
        Router.__init__(self, addr)  # initialize superclass - don't remove
        self.heartbeatTime = heartbeatTime
        self.last_time = 0
        # Hints: initialize local state
        self.seq_num = 0
        # Yeah, NetworkX is fancinating!
        self.G = nx.Graph()
        self.G.add_node(self.addr)
        self.forward_table = dict() # address (string) -> port (int)
        self.ports = dict() # port (int) -> address (string)

    
    def dijkstra(self):
        shortest_paths = nx.shortest_path(G=self.G, source=self.addr, weight='weight', method='dijkstra')
        for target, path in shortest_paths.items():
            self.forward_table[target] = path[1]
    
    def broadcast(self, seq_num, g, exclu_port):
        for port in self.links.keys():
            if port == exclu_port:
                continue
            packet = Packet(kind=Packet.ROUTING, srcAddr=self.addr, dstAddr=self.ports[port], content=dumps((seq_num, g)))
            self.send(port, packet)


    def handlePacket(self, port, packet):
        """TODO: process incoming packet"""
        if packet.isTraceroute():
            # Hints: this is a normal data packet
            # if the forwarding table contains packet.dstAddr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if packet.dstAddr in self.forward_table:
                self.send(self.forward_table[packet.dstAddr], packet)
        else:
            # Hints: this is a routing packet generated by your routing protocol
            # check the sequence number
            # if the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            seq_num, g = loads(packet.content)
            if seq_num <= self.seq_num:
                return
            self.seq_num = seq_num
            # update link-state (i.e. graph) to achieve consistency
            self.G = g
            self.dijkstra()
            self.broadcast(seq_num, g, port)


    def handleNewLink(self, port, endpoint, cost):
        """TODO: handle new link"""
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors
        self.ports[port] = endpoint
        self.G.add_edge(self.addr, endpoint, weight=cost)
        self.dijkstra()  
        self.seq_num += 1
        self.broadcast(self.seq_num, self.G, None)


    def handleRemoveLink(self, port):
        """TODO: handle removed link"""
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors
        self.G.remove_edge(self.addr, self.ports[port])
        self.ports.pop(port)
        self.dijkstra()
        self.seq_num += 1
        self.broadcast(self.seq_num, self.G, None)


    def handleTime(self, timeMillisecs):
        """TODO: handle current time"""
        if timeMillisecs - self.last_time >= self.heartbeatTime:
            self.last_time = timeMillisecs
            # Hints:
            # broadcast the link state of this router to all neighbors
            self.broadcast(self.seq_num, self.G, None)


    def debugString(self):
        """TODO: generate a string for debugging in network visualizer"""
        return "addr: {}".format(self.addr)
